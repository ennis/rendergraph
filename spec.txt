
// All synthesized attributes are lazily evaluated
// All synthesized attributes are stored in 'descriptors'

Module(env) :=
	Imports(env)

	memberEnv <- {
        env + declSet
	}

    // note that there is a cyclic dependency between memberEnv and declSet synthesized attributes, to allow for forward references
	Declarations(declSet) := (Component(memberEnv) | Function(memberEnv))*


Component(in env, out decl) :=

	Name := identifier(name)
		{
		     // Name must not be already in env (redeclaration)
		     decl.name <- name
		}

	Bases := path* 
		{
	        // all bases must be component definitions
	        // all paths in bases must be in env
	        // values defined in bases must not conflict

		    allValues = hashmap<String, Value>();
		    foreach(b in component.bases) {
		        bdef = env.getDefinition<Component>();
                // query synthesized attribute: members
                members = bdef.members
                // check intersection of members with allValues
                if (intersection(members,allValues) != null) ERROR()
                allValues = { members + allValues }
		    }
		}


	inherited <- {
	    // union of all memberEnv for each base
	}
	
	env2 <- {
	    env + inherited + members
	}

	Members(out members) := (MemberFunction(env2) | AssociatedConstant(env2))* { }


MemberFunction (env) := 
	Function (env)

Function(env) :=
	
	Name := identifier 
		// PASS 1 CHECK
		{ /* first pass: check that it is not already present in env */ }

	ReturnType := path { path in env }	// visibility check
	Arguments := Argument(env)*

	// environment for body check is definition environment + arguments
	bodyEnv <- env + { forall a in Arguments: a.name -> a }



// Resolution rules are implemented in XXXResolver classes
	// ModuleResolver(env, ...).resolveModule(RgModule) -> Module
	// ModuleResolver(env, ...).buildForwardReferenceSet()
// Environment is not contained in 'descriptor' classes
// Where are the scopes filled?
	// in resolver?
	// after construction of the descriptor? setter?
	// inside the descriptor?
	// ** created as-needed during resolution (no need to store useless data)

Create a module instance
	- traverse all declarations of the module
	- if a declaration needs a definition from the module
- Resolve on-demand:
	- type, returnType, argumentType is Lazy
		-> stores a reference to the PSI element
- Module scope resolution:
	- create declarations, but do not resolve inside (but: provide callbacks to do so)
	- Function( arguments: List<Argument>, returnType: Lazy<Type> )
	- Argument( val name, val type: Lazy<Type>, val defaultValue: Lazy<Expression>)
- Type queries can happen anywhere in the PSI!
- Lazy scopes:
	- 

Minimal viable product:
	- All GLSL statements and expressions
	-
